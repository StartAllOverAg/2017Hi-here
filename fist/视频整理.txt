## 关于内存释放和作用域销毁
  ## 堆内存
- 引用数据类型在定义时首先会开辟个堆内存，堆内存有一个引用的地址，如果外面
    有变量知道了这个地址，这个内存就被占用了，不能销毁
- 想让堆内存释放/销毁，需要吧所有引用它的变量赋值为null，如果 当前的堆内存没有任何东西被占用了，
  那么浏览器会在空闲时销毁它
  ##  栈内存
  1>全局作用域
      只有的当页面关闭的时候全局作用域才会销毁
  2>私有的作用域（只有函数执行会产生私有的作用域）
    一般情况下，函数执行会形成一个新的私有作用域，当私有作用域中代码执行完成之后，销毁
#### 特殊情况：
  当前私有作用域中的部分内存被作用域以外占用了，当前作用域就不能销毁
     A、函数执行返回了一个引用数据类型的值，并且在函数外面被一个其他的东西接收了，这种情况下一半形成的私有作用域不会销毁
     var f=fn();
onclick 默认值存的是null
     B、在一个私有的作用域中给DOM元素的事件绑定方法，一般情况下私有作用域都不销毁
     C、下述情况属于不立即销毁 fn返回的函数没有被其他的东西占用单还是在执行一次不暂时销毁   当返回值执行完成后，会销毁
     fn()();首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行

## 关于得不到释放和不立即释放
当函数体中的任何东西，被外面的变量或者其它东西占用的时候，比如被外面一个变量接受。这个函数形成的栈内存得不到释放
当函数执行完成的时候，返回一个需要执行的函数，需要等待所有的函数都执行完成的时候，这个函数将会释放。这个叫不立即释放。但执行完了。就会释放了。所以得谨记

## this
js中的this代表的是当前行为执行的主题；context代表的是当前行为执行的环境（区域）
**this在哪儿定义的和在哪儿执行的都没任何关系；**
#### 如何区分this？？？
 1、函数执行，首先看函数名前面是否有点，有的话 前面是谁就是谁，没有就是window
 2、自执行函数中的this永远是window
 3、给元素的某一个事件绑定方法，当事件触发的时候，绑定的方法执行

## 对象数据类型的作用：
  - 吧描述同一个事物（同一个对象）的属性和方法放在 一个内存空间下；起到了分组的作用，不同事物之间的属性即使属性名相同相互也不会冲突     这种分组编写代码的模式叫“单例模式”
js中有一个内置的类array【数组类】，



#  单例模式是项目开发中经常使用的模式。项目中可以使用单例模式进行“模块开发”
### 模块开发  对于一个相对比较大的项目，需要多人协作的开发，一般情况下会根据
# 工厂模式
> 能批量生产  把实现同一件事情相同的代码放到一个函数中，在想实现就不需要从写。只需要执行当前函数就行"函数的封装"
>　“低耦合高内聚”：减少页面的冗余，提高代码的重复利用率
```

 function asd(name,age){
 var obj={};
 obj.name=name;
 obj.age=age;
 obj.qwe=function(){
 alert(this.name+this.age)
 }
 return obj;
 }
 console.log("sads",51);
```
类的继承：子类继承父类中的属性方法
类的封装：吧相同代码放到一个函数中
类的多态：当前方法的多种形态
  后台语言中：多态包含　重载和重写
   重载是方法名一样  参数不一样
**ｊｓ中不存在重载    有类似重载但不是重载：可根据传递参数的不一样，实现不同功能  **
```
function sun(num){
}
sum(100);sum();
```

重写存在 ：子类重写父类的方法

# 构造函数目的：创建一个自定义类，并且创建这个类的实例
1、**js中所有的类都是函数数据类型的**，通过new执行变成了一个类，本身也是函数
**js中所有实例都是对象数据类型的**
2、**构造模式中，类中（函数体中）this是当前类的一个实例**
3、接受函数都是asd这个类的实例，都拥有这个方法，但不同实例直接方法不一样
     在类中给实例增加的属性属于当前实例的私有属性，实例和实例直接是单独的个体，私有的属性之间是不相等的
构造函数中没有return  普通可有可无


**构造函数模式与工厂模式的区别：**
1、执行时new一个 普通 asd（）  构造函数模式 new asd（）
通过new执行后  asd就是一个类
　函数执行的返回值（接受函数）就是asd这个的一个实例

**创建一个数组  var arry=[] 字面量方式和var arry=new Array()   实例创建方式**  不管哪种方式都是Array这个类的一个实例

2、在函数代码执行的时候
**相同点**：都是形成一个私有作用域，然后 形参赋值->预解释->代码从上到下执行（类和普通函数一样，也有普通一面）
**不同**：在代码执行之前，不同在手动创建对象，浏览器会默认创建一个对象数据类型值（这个对象就是当前一个类的实例）接着从上到下执行，以当前的实例为执行的主体（this代表的就是当前），然后分别吧属性名、属性值赋值给当前的实例，最后返回



