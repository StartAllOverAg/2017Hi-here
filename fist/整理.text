### 数据类型
 - 基本数据类型：number,string,boolean,null,undefined
 - 引入数据类型：对象类型、array,regexp,object函数类型、function
#### 基本数据类型操作的是值  引用数据类型操作的是地址
### 预解释（*变量提升*）
  >只针对当前作用域 只发生在当前作用域中 首先开始对window进行预解释  执行时会形成一个私有
  作用域  然后  函数执行的时候也会进行预解释
- 在当前作用域,Js代码执行前，吧所有带var和带function关键字的进行声明或者定义
 （window是全局作用域）
-  声明 var  num  function  fn      **预解释的时候带var只声明  不定义**
- 定义  赋值  num=321   **通过var声明的时候 会给变量赋值一个默认值undefined**
- 预解释完成后  代码自上而下执行
#### 全局变量   就是在全局作用域中声明的变量
####   私有变量    就是在私有作用域中声明的变量
####  函数执行  将函数里的js代码加载运行  需要一个供函数里js代码执行环境->私有
    - 作用域链  如果在私有作用域中遇到一个变量，先看是否是形参或也没有在预解释声明过；
    如果没有声明过也不是形参，就会去上级作用域查找，找到window为止
 > 如何看上级作用域
  看函数是在哪儿定义的
  return 后面的会被当成一个返回值    报错  如果没有return输出内容
## Linux 常用命令
####  mkdir  创建文件夹
  - -p递归创建
  ```
  makdir -p cc/ee  //创建了两个文件夹   父子关系
  ```
  - touch 创建文件
  ```
  touch 文件名
  ```
  - echo 写入内容
  ```
  echo hello>文件名   //将hello写入到文件tex里    覆盖前面的
  ```
  ```
  echo word>>文件名   //不会覆盖hello    Word 和 hello 都在
  ```
  - Cat   文件          查看文件里的内容
  - cd  目录路径
  - ls              查看当前目录下有哪些文件
  ```
  ls -al(-a 只看文件夹    -al查看所有的详细信息)
  ```
  - cd ..           回到当前目录父级目录
  - pwd                  查看当前所在目录
  - rm -rf  文件名        删除文件夹
  #### 在全局作用域中声明的变量，不仅是全局变量也是全局作用域的属性
   > 函数执行形成一个私有作用域  保护里面理由变量 不收外界干扰 的保护机制叫闭包
   >　全局不能改变私有的

### 堆内存
堆内存用来存储应用数据类型的值
对象和属性值    对象类    存储的值


### 栈内存  作用域  环境
供js代码执行的环境
- window (栈内存)  关闭浏览器的时候就会销毁
- 一般情况下函数执行形成私有作用域(栈内存) 执行完成代码  就会立即销毁


### 内存释放
浏览器默认机制  每间隔一段时间会吧那些  没有被占用的 内存回收
> 在私有作用域（栈内存）中，返回一个引用数据类型 呗外部接受 就不能被销毁

> 不立即销毁 如果返回的是一个函数数据类型  要等返回值执行完后  才能销毁


## 预解释   引用数据类型会开辟一个空间，吧函数体重的代码以字符串形式存储起来
   给一个虚拟的地址
- fn  吧整个函数的定义部分（函数本身）输出
- fn()吧当前函数执行的返回结果，return后面是啥就是啥，没有就默认是undefined
   #### 预解释
   **在当前的作用域中，js代码执行前浏览器首先吧所有带var function进行提前的声明或定义**
声明 ： 就是容器  变量
定义 ： 给容器或变量  赋值
 ### var 不重复声明    带function不重复声明   重复定义
  var  只声明  不定义   function 声明 定义  一起完成
- 预解释只发生在当前的作用域下  在函数执行的时候才会预解释里面的
## return后面的代码虽然不执行了，但是需要进行预解释，return后面跟的是返回的值，所以不进行预解释

## 在预解释中，如果名字已经声明了，不需要重新声明  需要重新赋值

## 形参中没有储存实参值的功能   内部具有储存形参值的功能

##  第三天
>  **this  全局中的this是window**
> 函数中的this要看函数执行的时候前面有没有‘.’，如果有点 前面是谁this就是谁
> ***函数中的this和函数在哪里执行、在哪里定义没有任何关系  只看执行的时候***     自执行函数中的this是window
> 自执行函数里面的this永远是window
> 给元素绑定事件  事件触发的时候  里面的this 就是当前绑定事件的元素
> 定时器中的this也是window

## 对象数据

#### 单利模式：**手工作业**  缺点：麻烦  单个执行
把描述一个事物（或一个对象）放在一个内存空间，起到分组的作用  2>即使属性名相同也不会发生冲突
 “模块化开发”，项目中 开发模块比较多的时候，多人协作  最终将代码何在一起
 单例模式把  x1 和  x2 称为“命名空间”
```
var filigthFH={
      title:"这是机票"；
      mess；'欢迎你来到糯米鸡购票';
      say;function (){
      alert('这个是'+this.title+'.'+this.mess)}
}
```
#### 工厂模式
把实现一个功能的代码放到一个函数里面  减少冗长=余代码->“函数封装”
’高内聚低耦合‘：减少页面中重复代码  提高代码重复利用率
```
function peer(name,sex,hobby){
var obj={};
obj.name=name;
obj.sex=sex;
obj.hobby=hobby;
obj.say=function(){
console.log(this.name+""+this.sex+""+this.hobby);
}return obj;
}
var obj1=peer('谁打','男','额嗯')；
console.log(obj1);
obj1.say();

var obj2=peer('谁打','男','额嗯')；
console.log(obj2);
obj2.say();
```
### 面向对象
对象：是一个泛指
类：对对象的具体细分    类的：封装  继承 多态
       继承：子类继承父类
       多态：多种形态（重载和从写）js中没有重载       重写~子类从写父类

> 实例：类中某一个具体事物
    var qrr1=[1,2,3]  字面量方式
    var qrr2=new Array(1,2,3,)  实例创建方式->构造函数模式执行的方式

### 内置类
> 构造函数的目的 创建一个自定义类 并且创建这个类的实例
普通的 类 需要return返回值才能返回      内置类 new 类名（属性值）  返回的就是结果
在类中的this.xxx是给 当前实例添加属性 类中的this是当前实例
类本身也是个函数
js类都是函数数据类型
js实例都是对象类型

## 工厂模式和构造函数模式的区别
 **1、工厂模式  普通函数执行 构造函数通过new 来执行 默认创建一个对象  将其返回作为这个类的实例**
 **2、执行的时候形成一个私有作用域->形参赋值->预解释->代码 从上到下执行**
    不同：构造函数模式执行的时候  会默认创建一个对象  默认返回的实例    工厂模式 自己手工创建
  ```
  funciton sum(name,age){
  执行之前浏览器默认创建一个对象
  this.name=name;  给当前实例添加私有属性
  this.age=age;
  默认这个对象返回
  }
  var psd=new sum('asd',20);
  console.log(psd)_

  ```
**instanceof 用来检测一个实例是否属于这个类**   object 基类

### 构造函数模式执行的时候 如果指定返回的  是一个引用数据类型  那么返回的就是这个引用数据类型

公用的是一个类的情况下  实例！=实例是单独的个体

### 构造函数的扩展
1、在构造函数中new fn（）执行，如果不需要传递参数的话，后面的小括号可以省略
2、this的问题，在类中出现的this，xxx中的this都是当前类的实例，而某一个属性值（方法），方法中的this需要看方法执行的时候，前面是否有点，才能知道this是谁  在此赋予实例时就是window
3、类有普通函数的一面，档函数执行的时候，var num其实只是当前形成的自由作用域的私有变量，和实例没有任何关系；只有this.xxx才相当于实例增加私有属性和方法，才和实例有关系
4、浏览器子啊构造函数模式中，会默认的吧我们的实例返回的是一个对象数据类型的值，如果手动写了return返回：1》返回是一个基本数据类型的值，当前实例是不变的，2》返回是一个引用数据类型值，当前实例会被自己返回的值替换掉，例如return name；zhufeng     就是zhufeng
5、检测某一实例是否属于这个类->instanceof
console.log(f1 instanceof fn);

in  检测某一个属性是否属于这个对象，不管是私有属性还是公有属性，只要存在，用in检测都是true


